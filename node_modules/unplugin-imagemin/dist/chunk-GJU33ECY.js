"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }// src/core/compressOptions.ts
var defaultOptions = {
  jpeg: {
    extension: /.(jpg|jpeg)$/,
    quality: 75,
    baseline: false,
    arithmetic: false,
    progressive: true,
    optimize_coding: true,
    smoothing: 0,
    color_space: 3,
    quant_table: 3,
    trellis_multipass: false,
    trellis_opt_zero: false,
    trellis_opt_table: false,
    trellis_loops: 1,
    auto_subsample: true,
    chroma_subsample: 2,
    separate_chroma_quality: false,
    chroma_quality: 75
  },
  mozjpeg: {
    extension: /.(jpg|jpeg)$/,
    quality: 75,
    baseline: false,
    arithmetic: false,
    progressive: true,
    optimize_coding: true,
    smoothing: 0,
    color_space: 3,
    quant_table: 3,
    trellis_multipass: false,
    trellis_opt_zero: false,
    trellis_opt_table: false,
    trellis_loops: 1,
    auto_subsample: true,
    chroma_subsample: 2,
    separate_chroma_quality: false,
    chroma_quality: 75
  },
  png: {
    extension: /.webp$/,
    quality: 75,
    target_size: 0,
    target_PSNR: 0,
    method: 4,
    sns_strength: 50,
    filter_strength: 60,
    filter_sharpness: 0,
    filter_type: 1,
    partitions: 0,
    segments: 4,
    pass: 1,
    show_compressed: 0,
    preprocessing: 0,
    autofilter: 0,
    partition_limit: 0,
    alpha_compression: 1,
    alpha_filtering: 1,
    alpha_quality: 100,
    lossless: 0,
    exact: 0,
    image_hint: 0,
    emulate_jpeg_size: 0,
    thread_level: 0,
    low_memory: 0,
    near_lossless: 100,
    use_delta_palette: 0,
    use_sharp_yuv: 0
  },
  webp: {
    extension: /.webp$/,
    quality: 75,
    target_size: 0,
    target_PSNR: 0,
    method: 4,
    sns_strength: 50,
    filter_strength: 60,
    filter_sharpness: 0,
    filter_type: 1,
    partitions: 0,
    segments: 4,
    pass: 1,
    show_compressed: 0,
    preprocessing: 0,
    autofilter: 0,
    partition_limit: 0,
    alpha_compression: 1,
    alpha_filtering: 1,
    alpha_quality: 100,
    lossless: 0,
    exact: 0,
    image_hint: 0,
    emulate_jpeg_size: 0,
    thread_level: 0,
    low_memory: 0,
    near_lossless: 100,
    use_delta_palette: 0,
    use_sharp_yuv: 0
  },
  avif: {
    extension: /.avif$/,
    cqLevel: 33,
    cqAlphaLevel: -1,
    denoiseLevel: 0,
    tileColsLog2: 0,
    tileRowsLog2: 0,
    speed: 6,
    subsample: 1,
    chromaDeltaQ: false,
    sharpness: 0,
    tune: 0
  },
  jxl: {
    extension: /.jxl$/,
    effort: 1,
    quality: 75,
    progressive: false,
    epf: -1,
    lossyPalette: false,
    decodingSpeedTier: 0,
    photonNoiseIso: 0,
    lossyModular: false
  },
  wp2: {
    extension: /.wp2$/,
    quality: 75,
    alpha_quality: 75,
    effort: 5,
    pass: 1,
    sns: 50,
    uv_mode: 0,
    csp_type: 0,
    error_diffusion: 0,
    use_random_matrix: false
  },
  oxipng: {
    extension: /.png$/,
    level: 2
  }
};
var sharpOptions = {
  avif: {
    quality: 50,
    lossless: false,
    effort: 4,
    chromaSubsampling: "4:4:4"
    // options.quality number  quality, integer 1-100 (optional, default 50)
    // options.lossless boolean  use lossless compression (optional, default false)
    // options.effort number  CPU effort, between 0 (fastest) and 9 (slowest) (optional, default 4)
    // options.chromaSubsampling string  set to '4:2:0' to use chroma subsampling (optional, default '4:4:4')
  },
  jpeg: {
    //     quality (Number) 图片质量，整数1-100(可选，默认80)
    // progressive (Boolean) 使用渐进式(交错)扫描(可选，默认为false)
    // chromaSubsampling (String) 设置为“4:4:4”，以防止质量<= 90时色度子采样(可选，默认为“4:2:0”)
    // trellisQuantisation (Boolean) 应用网格量化，需要mozjpeg(可选，默认为false)
    // overshootDeringing (Boolean) 应用超调脱靶，需要mozjpeg(可选，默认为false)
    // optimiseScans (Boolean) 优化渐进式扫描，强制渐进式扫描，要求mozjpeg(可选，默认为false)
    // optimizeScans (Boolean) optimisescan的替代拼写(可选，默认为false)
    // optimiseCoding (Boolean) 优化Huffman编码表(可选，默认为true)
    // optimizeCoding (Boolean) optimiseCoding的替代拼写(可选，默认为true)
    // quantisationTable (Number) 要使用量子化表，整数0-8，需要mozjpeg(可选，默认为0)
    // quantizationTable(Number) quantisationTable的替代边写，整数0-8，需要mozjpeg(可选，默认为0)
    // force (Boolean) 强制JPEG输出，否则尝试使用输入格式(可选，默认为true)
    quality: 75,
    progressive: false,
    chromaSubsampling: "4:4:4",
    trellisQuantisation: false,
    overshootDeringing: false,
    optimiseScans: false,
    optimizeScans: false,
    optimiseCoding: true,
    optimizeCoding: true,
    quantisationTable: 0,
    quantizationTable: 0,
    force: true
  },
  jpg: {
    //     quality (Number) 图片质量，整数1-100(可选，默认80)
    // progressive (Boolean) 使用渐进式(交错)扫描(可选，默认为false)
    // chromaSubsampling (String) 设置为“4:4:4”，以防止质量<= 90时色度子采样(可选，默认为“4:2:0”)
    // trellisQuantisation (Boolean) 应用网格量化，需要mozjpeg(可选，默认为false)
    // overshootDeringing (Boolean) 应用超调脱靶，需要mozjpeg(可选，默认为false)
    // optimiseScans (Boolean) 优化渐进式扫描，强制渐进式扫描，要求mozjpeg(可选，默认为false)
    // optimizeScans (Boolean) optimisescan的替代拼写(可选，默认为false)
    // optimiseCoding (Boolean) 优化Huffman编码表(可选，默认为true)
    // optimizeCoding (Boolean) optimiseCoding的替代拼写(可选，默认为true)
    // quantisationTable (Number) 要使用量子化表，整数0-8，需要mozjpeg(可选，默认为0)
    // quantizationTable(Number) quantisationTable的替代边写，整数0-8，需要mozjpeg(可选，默认为0)
    // force (Boolean) 强制JPEG输出，否则尝试使用输入格式(可选，默认为true)
    quality: 75,
    progressive: false,
    chromaSubsampling: "4:4:4",
    trellisQuantisation: false,
    overshootDeringing: false,
    optimiseScans: false,
    optimizeScans: false,
    optimiseCoding: true,
    optimizeCoding: true,
    quantisationTable: 0,
    quantizationTable: 0,
    force: true
  },
  // progressive (Boolean) 使用渐进式(交错)扫描(可选，默认为false)
  // compressionLevel (Number) zlib压缩级别，0-9(可选，默认9)
  // adaptiveFiltering (Boolean) 使用自适应行筛选(可选，默认为false)
  // force (Boolean) 强制PNG输出，否则尝试使用输入格式(可选，默认为true)
  png: {
    progressive: false,
    compressionLevel: 6,
    adaptiveFiltering: false,
    force: true,
    palette: true,
    quality: 75,
    effort: 5,
    bitdepth: 8,
    dither: 1
  },
  // options (Object)
  // quality (Number) 质量，整数1-100(可选，默认80)
  // alphaQuality (Number) alpha层的质量，整数0-100(可选，默认100)
  // lossless (Boolean) 使用无损压缩模式(可选，默认为false)
  // nearLossless (Boolean) 使用接近无损压缩模式(可选，默认为false)
  // force (Boolean) 强制WebP输出，否则尝试使用输入格式(可选，默认为true)
  webp: {
    quality: 75,
    alphaQuality: 100,
    lossless: false,
    nearLossless: false,
    smartSubsample: false,
    effort: 4
  },
  // quality (Number) 质量，整数1-100(可选，默认80)
  // force (Boolean) 强制TIFF输出，否则尝试使用输入格式(可选，默认为true)
  // compression (Boolean) 压缩选项:lzw, deflate, jpeg, ccittfax4(可选，默认'jpeg')
  // predictor (String) 压缩预测器选项:无、水平、浮动(可选、默认“水平”)
  // xres (Number) 水平分辨率(像素/mm)(可选，默认1.0)
  // yres (Number) 垂直分辨率(像素/mm)(可选，默认1.0)
  // squash (Boolean) 将8位图像压缩到1位(可选，默认为false)
  tiff: {
    quality: 80,
    compression: "jpeg",
    predictor: "horizontal",
    pyramid: false,
    bitdepth: 8,
    tile: false,
    tileHeight: 256,
    tileWidth: 256,
    xres: 1,
    yres: 1,
    resolutionUnit: "inch"
  }
  // gif
  //   options.reoptimise boolean  always generate new palettes (slow), re-use existing by default (optional, default false)
  // options.reoptimize boolean  alternative spelling of options.reoptimise (optional, default false)
  // options.colours number  maximum number of palette entries, including transparency, between 2 and 256 (optional, default 256)
  // options.colors number  alternative spelling of options.colours (optional, default 256)
  // options.effort number  CPU effort, between 1 (fastest) and 10 (slowest) (optional, default 7)
  // options.dither number  level of Floyd-Steinberg error diffusion, between 0 (least) and 1 (most) (optional, default 1.0)
  // options.loop number  number of animation iterations, use 0 for infinite animation (optional, default 0)
  // options.delay (number  | Array <number >)? delay(s) between animation frames (in milliseconds)
  // options.force boolean  force GIF output, otherwise attempt to use input format (optional, default true)
};
var resolveDefaultOptions = {
  mode: "sharp",
  conversion: [],
  beforeBundle: false,
  cache: false,
  compress: {
    jpg: {
      quality: 70
    },
    jpeg: {
      quality: 70
    },
    png: {
      quality: 70
    },
    webp: {
      quality: 70
    }
  }
};

// src/index.ts
var _unplugin = require('unplugin');

// src/core/encodeMap.ts
var encodeMap = /* @__PURE__ */ new Map([
  ["mozjpeg", "jpeg"],
  ["browserjpeg", "jpeg"],
  ["mozjpeg", "jpg"],
  ["browserjpeg", "jpg"],
  ["jxl", "jxl"],
  ["avif", "avif"],
  ["oxipng", "png"],
  ["browserpng", "png"],
  ["webp", "webp"],
  ["wp2", "wp2"],
  ["jpg", "jpg"],
  ["png", "png"]
]);
var encodeMapBack = /* @__PURE__ */ new Map([
  ["jpeg", "mozjpeg"],
  ["jpg", "mozjpeg"],
  ["jxl", "mozjpeg"],
  ["avif", "avif"],
  ["png", "webp"],
  ["webp", "webp"],
  ["wp2", "wp2"]
]);
var sharpEncodeMap = /* @__PURE__ */ new Map([
  ["jpeg", "jpeg"],
  ["png", "png"],
  ["jpg", "jpeg"],
  ["avif", "avif"],
  ["webp", "webp"]
]);

// src/core/context.ts
var _pluginutils = require('@rollup/pluginutils');
var _buffer = require('buffer');
var _perf_hooks = require('perf_hooks');
var _svgo = require('svgo');

// node_modules/.pnpm/filesize@10.0.7/node_modules/filesize/dist/filesize.esm.js
var ARRAY = "array";
var BIT = "bit";
var BITS = "bits";
var BYTE = "byte";
var BYTES = "bytes";
var EMPTY = "";
var EXPONENT = "exponent";
var FUNCTION = "function";
var IEC = "iec";
var INVALID_NUMBER = "Invalid number";
var INVALID_ROUND = "Invalid rounding method";
var JEDEC = "jedec";
var OBJECT = "object";
var PERIOD = ".";
var ROUND = "round";
var S = "s";
var SI_KBIT = "kbit";
var SI_KBYTE = "kB";
var SPACE = " ";
var STRING = "string";
var ZERO = "0";
var STRINGS = {
  symbol: {
    iec: {
      bits: ["bit", "Kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"],
      bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
    },
    jedec: {
      bits: ["bit", "Kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"],
      bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
    }
  },
  fullform: {
    iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
    jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
  }
};
function filesize(arg, {
  bits = false,
  pad = false,
  base = -1,
  round = 2,
  locale = EMPTY,
  localeOptions = {},
  separator = EMPTY,
  spacer = SPACE,
  symbols = {},
  standard = EMPTY,
  output = STRING,
  fullform = false,
  fullforms = [],
  exponent = -1,
  roundingMethod = ROUND,
  precision = 0
} = {}) {
  let e = exponent, num = Number(arg), result = [], val = 0, u = EMPTY;
  if (base === -1 && standard.length === 0) {
    base = 10;
    standard = JEDEC;
  } else if (base === -1 && standard.length > 0) {
    standard = standard === IEC ? IEC : JEDEC;
    base = standard === IEC ? 2 : 10;
  } else {
    base = base === 2 ? 2 : 10;
    standard = base === 10 ? JEDEC : standard === JEDEC ? JEDEC : IEC;
  }
  const ceil = base === 10 ? 1e3 : 1024, full = fullform === true, neg = num < 0, roundingFunc = Math[roundingMethod];
  if (typeof arg !== "bigint" && isNaN(arg)) {
    throw new TypeError(INVALID_NUMBER);
  }
  if (typeof roundingFunc !== FUNCTION) {
    throw new TypeError(INVALID_ROUND);
  }
  if (neg) {
    num = -num;
  }
  if (e === -1 || isNaN(e)) {
    e = Math.floor(Math.log(num) / Math.log(ceil));
    if (e < 0) {
      e = 0;
    }
  }
  if (e > 8) {
    if (precision > 0) {
      precision += 8 - e;
    }
    e = 8;
  }
  if (output === EXPONENT) {
    return e;
  }
  if (num === 0) {
    result[0] = 0;
    u = result[1] = STRINGS.symbol[standard][bits ? BITS : BYTES][e];
  } else {
    val = num / (base === 2 ? Math.pow(2, e * 10) : Math.pow(1e3, e));
    if (bits) {
      val = val * 8;
      if (val >= ceil && e < 8) {
        val = val / ceil;
        e++;
      }
    }
    const p = Math.pow(10, e > 0 ? round : 0);
    result[0] = roundingFunc(val * p) / p;
    if (result[0] === ceil && e < 8 && exponent === -1) {
      result[0] = 1;
      e++;
    }
    u = result[1] = base === 10 && e === 1 ? bits ? SI_KBIT : SI_KBYTE : STRINGS.symbol[standard][bits ? BITS : BYTES][e];
  }
  if (neg) {
    result[0] = -result[0];
  }
  if (precision > 0) {
    result[0] = result[0].toPrecision(precision);
  }
  result[1] = symbols[result[1]] || result[1];
  if (locale === true) {
    result[0] = result[0].toLocaleString();
  } else if (locale.length > 0) {
    result[0] = result[0].toLocaleString(locale, localeOptions);
  } else if (separator.length > 0) {
    result[0] = result[0].toString().replace(PERIOD, separator);
  }
  if (pad && Number.isInteger(result[0]) === false && round > 0) {
    const x = separator || PERIOD, tmp = result[0].toString().split(x), s = tmp[1] || EMPTY, l = s.length, n = round - l;
    result[0] = `${tmp[0]}${x}${s.padEnd(l + n, ZERO)}`;
  }
  if (full) {
    result[1] = fullforms[e] ? fullforms[e] : STRINGS.fullform[standard][e] + (bits ? BIT : BYTE) + (result[0] === 1 ? EMPTY : S);
  }
  return output === ARRAY ? result : output === OBJECT ? {
    value: result[0],
    symbol: result[1],
    exponent: e,
    unit: u
  } : result.join(spacer);
}
function partial({
  bits = false,
  pad = false,
  base = -1,
  round = 2,
  locale = EMPTY,
  localeOptions = {},
  separator = EMPTY,
  spacer = SPACE,
  symbols = {},
  standard = EMPTY,
  output = STRING,
  fullform = false,
  fullforms = [],
  exponent = -1,
  roundingMethod = ROUND,
  precision = 0
} = {}) {
  return (arg) => filesize(arg, {
    bits,
    pad,
    base,
    round,
    locale,
    localeOptions,
    separator,
    spacer,
    symbols,
    standard,
    output,
    fullform,
    fullforms,
    exponent,
    roundingMethod,
    precision
  });
}

// src/core/utils.ts
var _crypto = require('crypto'); var _crypto2 = _interopRequireDefault(_crypto);
var _fs = require('fs'); var fs3 = _interopRequireWildcard(_fs); var fs4 = _interopRequireWildcard(_fs);
var size = partial({ base: 2, standard: "jedec" });
var extRE = /(png|jpeg|jpg|webp|wb2|avif)$/i;
function parseId(id) {
  const index = id.indexOf("?");
  if (index < 0) {
    return { path: id, query: {} };
  }
  const query = Object.fromEntries(new URLSearchParams(id.slice(index)));
  return {
    path: id.slice(0, index),
    query
  };
}
var isFunction = (arg) => typeof arg === "function";
var isRegExp = (arg) => Object.prototype.toString.call(arg) === "[object RegExp]";
function filterFile(file, filter) {
  if (filter) {
    const isRe = isRegExp(filter);
    const isFn = isFunction(filter);
    if (isRe) {
      return filter.test(file);
    }
    if (isFn) {
      return filter(file);
    }
  }
  return false;
}
function isTurnImageType(options) {
  const hasConversion = options;
  const hasType = !!(options == null ? void 0 : options.length);
  const isReallyType = options == null ? void 0 : options.every(
    (item) => item.from.match(extRE) && item.to.match(extRE)
  );
  return Boolean(hasConversion && hasType && isReallyType);
}
async function exists(path5) {
  return await _fs.promises.access(path5, _fs.constants.F_OK).then(
    () => true,
    () => false
  );
}
function generateImageID(filename, format2 = "jpeg") {
  return `${_crypto.createHash.call(void 0, "sha256").update(filename).digest("hex").slice(0, 8)}.${format2}`;
}
function transformFileName(file) {
  return file.substring(0, file.lastIndexOf(".") + 1);
}
function filterExtension(name, ext) {
  const reg = new RegExp(`.${ext}`);
  return Boolean(name.match(reg));
}

// node_modules/.pnpm/pathe@1.1.0/node_modules/pathe/dist/shared/pathe.92c04245.mjs
function normalizeWindowsPath(input = "") {
  if (!input || !input.includes("\\")) {
    return input;
  }
  return input.replace(/\\/g, "/");
}
var _UNC_REGEX = /^[/\\]{2}/;
var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
var _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
var normalize = function(path5) {
  if (path5.length === 0) {
    return ".";
  }
  path5 = normalizeWindowsPath(path5);
  const isUNCPath = path5.match(_UNC_REGEX);
  const isPathAbsolute = isAbsolute(path5);
  const trailingSeparator = path5[path5.length - 1] === "/";
  path5 = normalizeString(path5, !isPathAbsolute);
  if (path5.length === 0) {
    if (isPathAbsolute) {
      return "/";
    }
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator) {
    path5 += "/";
  }
  if (_DRIVE_LETTER_RE.test(path5)) {
    path5 += "/";
  }
  if (isUNCPath) {
    if (!isPathAbsolute) {
      return `//./${path5}`;
    }
    return `//${path5}`;
  }
  return isPathAbsolute && !isAbsolute(path5) ? `/${path5}` : path5;
};
var join = function(...arguments_) {
  if (arguments_.length === 0) {
    return ".";
  }
  let joined;
  for (const argument of arguments_) {
    if (argument && argument.length > 0) {
      if (joined === void 0) {
        joined = argument;
      } else {
        joined += `/${argument}`;
      }
    }
  }
  if (joined === void 0) {
    return ".";
  }
  return normalize(joined.replace(/\/\/+/g, "/"));
};
function cwd() {
  if (typeof process !== "undefined") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
var resolve = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    const path5 = index >= 0 ? arguments_[index] : cwd();
    if (!path5 || path5.length === 0) {
      continue;
    }
    resolvedPath = `${path5}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute(path5);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path5, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path5.length; ++index) {
    if (index < path5.length) {
      char = path5[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1)
        ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path5.slice(lastSlash + 1, index)}`;
        } else {
          res = path5.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var isAbsolute = function(p) {
  return _IS_ABSOLUTE_RE.test(p);
};
var _EXTNAME_RE = /.(\.[^./]+)$/;
var extname = function(p) {
  const match = _EXTNAME_RE.exec(normalizeWindowsPath(p));
  return match && match[1] || "";
};
var basename = function(p, extension) {
  const lastSegment = normalizeWindowsPath(p).split("/").pop();
  return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;
};

// src/core/context.ts
var _sharp = require('sharp'); var _sharp2 = _interopRequireDefault(_sharp);
var _promises = require('fs/promises');


// src/core/devalue.ts
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  const counts = /* @__PURE__ */ new Map();
  let logNum = 0;
  function log(message) {
    if (logNum < 100) {
      console.warn(message);
      logNum += 1;
    }
  }
  function walk(thing) {
    if (typeof thing === "function") {
      log(`Cannot stringify a function ${thing.name}`);
      return;
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      const type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          const proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            if (typeof thing.toJSON !== "function") {
              log(
                `Cannot stringify arbitrary non-POJOs ${thing.constructor.name}`
              );
            }
          } else if (Object.getOwnPropertySymbols(thing).length > 0) {
            log(
              `Cannot stringify POJOs with symbolic keys ${Object.getOwnPropertySymbols(
                thing
              ).map((symbol) => symbol.toString())}`
            );
          } else {
            Object.keys(thing).forEach((key) => walk(thing[key]));
          }
      }
    }
  }
  walk(value);
  const names = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a, b) => b[1] - a[1]).forEach((entry, i) => {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    const type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify(thing.valueOf())})`;
      case "RegExp":
        return thing.toString();
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "Array":
        const members = thing.map((v, i) => i in thing ? stringify(v) : "");
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify).join(",")}])`;
      default:
        if (thing.toJSON) {
          let json = thing.toJSON();
          if (getType(json) === "String") {
            try {
              json = JSON.parse(json);
            } catch (e) {
            }
          }
          return stringify(json);
        }
        if (Object.getPrototypeOf(thing) === null) {
          if (Object.keys(thing).length === 0) {
            return "Object.create(null)";
          }
          return `Object.create(null,{${Object.keys(thing).map(
            (key) => `${safeKey(
              key
            )}:{writable:true,enumerable:true,value:${stringify(
              thing[key]
            )}}`
          ).join(",")}})`;
        }
        return `{${Object.keys(thing).map((key) => `${safeKey(key)}:${stringify(thing[key])}`).join(",")}}`;
    }
  }
  const str = stringify(value);
  if (names.size) {
    const params = [];
    const statements = [];
    const values = [];
    names.forEach((name, thing) => {
      params.push(name);
      if (isPrimitive(thing)) {
        values.push(stringifyPrimitive(thing));
        return;
      }
      const type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v, i) => {
            statements.push(`${name}[${i}]=${stringify(v)}`);
          });
          break;
        case "Set":
          values.push("new Set");
          statements.push(
            `${name}.${Array.from(thing).map((v) => `add(${stringify(v)})`).join(".")}`
          );
          break;
        case "Map":
          values.push("new Map");
          statements.push(
            `${name}.${Array.from(thing).map(([k, v]) => `set(${stringify(k)}, ${stringify(v)})`).join(".")}`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key) => {
            statements.push(`${name}${safeProp(key)}=${stringify(thing[key])}`);
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str;
  }
}
function getName(num) {
  let name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? `${name}0` : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string") {
    return stringifyString(thing);
  }
  if (thing === void 0) {
    return "void 0";
  }
  if (thing === 0 && 1 / thing < 0) {
    return "-0";
  }
  const str = String(thing);
  if (typeof thing === "number") {
    return str.replace(/^(-)?0\./, "$1.");
  }
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? `.${key}` : `[${escapeUnsafeChars(JSON.stringify(key))}]`;
}
function stringifyString(str) {
  let result = '"';
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += `\\u${code.toString(16).toUpperCase()}`;
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
var devalue_default = devalue;

// src/core/context.ts
var _chalk = require('chalk'); var _chalk2 = _interopRequireDefault(_chalk);

// src/core/log.ts


function compressSuccess(filePath, newSize, oldSize, start) {
  console.log(
    _chalk2.default.blue(filePath.replace("/", "")),
    _chalk2.default.yellow(size(oldSize).toString()),
    "\u27A1\uFE0F ",
    _chalk2.default.green(size(newSize).toString()),
    _chalk2.default.magenta(`+${Math.ceil(_perf_hooks.performance.now() - start)}ms`)
  );
}
function pluginTitle(emoji) {
  return _chalk2.default.blue(`[unplugin-imagemin] ${emoji} ${emoji}`);
}
function logger(...args) {
  console.log(...args);
}

// src/core/gradient.ts

var _ora = require('ora'); var _ora2 = _interopRequireDefault(_ora);
var gradientColors = [
  `#c7ecee`,
  `#c6ebff`,
  `#a6dfff`,
  `#7ac4ff`,
  `#62baff`,
  `#48afff`,
  `#31a4ff`,
  `#afa0ff`,
  `#9b88ff`,
  `#a564ff`,
  `#974cff`,
  `#832aff`
];
var rocketAscii = "\u25B6";
var referenceGradient = [
  ...gradientColors,
  // draw the reverse of the gradient without
  // accidentally mutating the gradient (ugh, reverse())
  ...[...gradientColors].reverse(),
  ...gradientColors
];
var sleep = (time) => new Promise((resolve2) => {
  setTimeout(resolve2, time);
});
function getGradientAnimFrames() {
  const frames = [];
  for (let start = 0; start < gradientColors.length * 2; start++) {
    const end = start + gradientColors.length - 1;
    frames.push(
      referenceGradient.slice(start, end).map((g) => {
        return _chalk2.default.bgHex(g)(" ");
      }).join("")
    );
  }
  return frames;
}
function getIntroAnimFrames() {
  const frames = [];
  for (let end = 1; end <= gradientColors.length; end++) {
    const leadingSpacesArr = Array.from(
      new Array(Math.abs(gradientColors.length - end - 1)),
      () => " "
    );
    const gradientArr = gradientColors.slice(0, end).map((g) => _chalk2.default.bgHex(g)(" "));
    frames.push([...leadingSpacesArr, ...gradientArr].join(""));
  }
  return frames;
}
async function loadWithRocketGradient(text) {
  const frames = getIntroAnimFrames();
  const intro = _ora2.default.call(void 0, {
    spinner: {
      interval: 30,
      frames
    },
    text: `${rocketAscii} ${text}`
  });
  intro.start();
  await sleep((frames.length - 1) * intro.interval);
  intro.stop();
  const spinner = _ora2.default.call(void 0, {
    spinner: {
      interval: 80,
      frames: getGradientAnimFrames()
    },
    text: `${rocketAscii} ${text}`
  }).start();
  return spinner;
}

// src/core/cache.ts

var _path = require('path'); var _path2 = _interopRequireDefault(_path);


// package.json
var package_default = {
  name: "unplugin-imagemin",
  version: "0.3.13",
  description: "\u{1F4E6} \u{1F4E6} unplugin compression Image Compression plugin based on squoosh and sharp",
  scripts: {
    bootstrap: "pnpm install && pnpm build",
    build: "tsup && pnpm build:fix",
    dev: "tsup --watch src && pnpm build:fix",
    "build:fix": "esno scripts/postbuild.ts",
    lint: "eslint .",
    format: "prettier --write .",
    play: "npm -C playground run dev",
    prepublishOnly: "npm run build",
    release: "bumpp && npm publish",
    start: "esno src/index.ts",
    test: "vitest"
  },
  main: "dist/index.js",
  module: "dist/index.mjs",
  types: "dist/index.d.ts",
  exports: {
    ".": {
      require: "./dist/index.js",
      import: "./dist/index.mjs"
    },
    "./*": "./*",
    "./nuxt": {
      require: "./dist/nuxt.js",
      import: "./dist/nuxt.mjs"
    },
    "./resolvers": {
      require: "./dist/resolvers.js",
      import: "./dist/resolvers.mjs"
    },
    "./rollup": {
      require: "./dist/rollup.js",
      import: "./dist/rollup.mjs"
    },
    "./types": {
      require: "./dist/types.js",
      import: "./dist/types.mjs"
    },
    "./vite": {
      require: "./dist/vite.js",
      import: "./dist/vite.mjs"
    },
    "./webpack": {
      require: "./dist/webpack.js",
      import: "./dist/webpack.mjs"
    },
    "./esbuild": {
      require: "./dist/esbuild.js",
      import: "./dist/esbuild.mjs"
    }
  },
  typesVersions: {
    "*": {
      "*": [
        "./dist/*",
        "./*"
      ]
    }
  },
  files: [
    "dist"
  ],
  keywords: [
    "unplugin",
    "vite",
    "webpack",
    "rollup",
    "esbuild",
    "imagemin"
  ],
  license: "MIT",
  devDependencies: {
    "@types/node": "^18.16.1",
    bumpp: "^9.1.0",
    eslint: "^8.39.0",
    "eslint-config-relaxed-ts": "^2.0.20",
    esno: "^0.16.3",
    "fast-glob": "^3.2.12",
    filesize: "^10.0.7",
    pathe: "^1.1.0",
    prettier: "^2.8.8",
    rimraf: "^4.4.1",
    tsup: "^6.7.0",
    turbo: "^1.9.3",
    typescript: "^5.0.4",
    vite: "4.3.3",
    vitest: "^0.29.8",
    webpack: "^5.81.0"
  },
  dependencies: {
    "@rollup/pluginutils": "^5.0.2",
    "@squoosh/lib": "^0.5.3",
    chalk: "^4.1.2",
    ora: "6.3.0",
    sharp: "0.32.0",
    svgo: "^3.0.2",
    unplugin: "^1.3.1"
  },
  engines: {
    node: "^14.18.0 || >=16.12.0"
  }
};

// src/core/cache.ts
var env = process.env.NODE_ENV || "development";
var root = process.cwd();
var cacheDirectory = _path2.default.join(
  root,
  "node_modules",
  ".cache",
  "unplugin-imagemin"
);
var cacheIdentifier = `unplugin-imagemin:${package_default.version} ${env}`;
var manifestKey = _path2.default.join(cacheDirectory, "manifest.json");
var Cache = class {
  constructor({ outputPath }) {
    this.outputPath = outputPath;
    this.manifest = getCacheManifest();
  }
  get(chunk) {
    const cacheKey = getCacheKey(chunk);
    if (!this.hasManifest(cacheKey)) {
      return null;
    }
    const originStats = fs3.default.statSync(_path2.default.join(root, chunk.name));
    const cacheStats = this.getManifest(cacheKey);
    if (originStats.ctimeMs === cacheStats.ctimeMs) {
      return fs3.default.readFileSync(cacheKey);
    }
    return null;
  }
  set(chunk, data) {
    const cacheKey = getCacheKey(chunk);
    if (!existsSync(cacheDirectory)) {
      mkdirSync(cacheDirectory);
    }
    fs3.default.writeFileSync(
      cacheKey,
      data || fs3.default.readFileSync(_path2.default.join(this.outputPath, chunk.fileName))
    );
    this.setManifest(cacheKey, fs3.default.statSync(_path2.default.join(root, chunk.name)));
  }
  getManifest(key) {
    return this.manifest[key];
  }
  setManifest(key, value) {
    this.manifest[key] = value;
    fs3.default.writeFileSync(manifestKey, JSON.stringify(this.manifest), "utf-8");
  }
  hasManifest(key) {
    return Boolean(this.manifest[key]);
  }
};
function getCacheManifest() {
  if (!existsSync(manifestKey)) {
    return {};
  }
  return JSON.parse(fs3.default.readFileSync(manifestKey, "utf-8")) || {};
}
function getCacheKey(chunk) {
  const hash = digest(`${cacheIdentifier}
${chunk.name}`);
  return _path2.default.join(cacheDirectory, `${hash}`);
}
function existsSync(existsPath) {
  return fs3.default.existsSync(existsPath);
}
function mkdirSync(mkdirPath) {
  fs3.default.mkdirSync(mkdirPath, { recursive: true });
}
function digest(str) {
  return _crypto2.default.createHash("md5").update(str).digest("hex");
}

// src/core/squoosh.ts
var _os = require('os'); var _os2 = _interopRequireDefault(_os);



var CurrentNodeVersion = parseInt(process.version.slice(1), 10);
var SquooshErrorVersion = 18;
var SquooshUseFlag = CurrentNodeVersion < SquooshErrorVersion;
var SquooshPool;
if (SquooshUseFlag) {
  Promise.resolve().then(() => _interopRequireWildcard(require("@squoosh/lib"))).then((module) => {
    SquooshPool = module.ImagePool;
    delete globalThis.navigator;
  }).catch((err) => {
    console.log(err);
  });
}
async function initSquoosh(config) {
  const {
    files,
    outputPath,
    cache,
    chunks,
    options,
    isTurn,
    defaultSquooshOptions
  } = config;
  let imagePool;
  if (options.mode === "squoosh") {
    imagePool = new SquooshPool(_os2.default.cpus().length);
  }
  const images = files.map(async (filePath) => {
    const fileRootPath = _path2.default.resolve(outputPath, filePath);
    if (options.cache && cache.get(chunks[filePath])) {
      fs3.writeFileSync(fileRootPath, cache.get(chunks[filePath]));
      logger(_chalk2.default.blue(filePath), _chalk2.default.green("\u2728 The file has been cached"));
      return Promise.resolve();
    }
    const start = Date.now();
    const image = imagePool.ingestImage(_path2.default.resolve(outputPath, filePath));
    const oldSize = fs3.lstatSync(fileRootPath).size;
    let newSize = oldSize;
    const ext = _nullishCoalesce(_path2.default.extname(_path2.default.resolve(outputPath, filePath)).slice(1), () => ( ""));
    const res = options.conversion.find((item) => `${item.from}`.includes(ext));
    const itemConversion = isTurn && (res == null ? void 0 : res.from) === ext;
    const type = itemConversion ? encodeMapBack.get(res == null ? void 0 : res.to) : encodeMapBack.get(ext);
    const current = encodeMap.get(type);
    await image.encode({
      [type]: defaultSquooshOptions[type]
    });
    const encodedWith = await image.encodedWith[type];
    newSize = encodedWith.size;
    if (newSize < oldSize) {
      const filepath = `${fileRootPath.replace(
        ext,
        itemConversion ? current : ext
      )}`;
      fs3.writeFileSync(filepath, encodedWith.binary);
      if (options.cache && !cache.get(chunks[filePath])) {
        cache.set(chunks[filePath], encodedWith.binary);
      }
      if (itemConversion) {
        fs3.unlinkSync(fileRootPath);
      }
      compressSuccess(
        `${filepath.replace(process.cwd(), "")}`,
        newSize,
        oldSize,
        start
      );
    }
  });
  await Promise.all(images);
  imagePool.close();
}
var squoosh_default = initSquoosh;

// src/core/sharp.ts





async function initSharp(config) {
  const { files, outputPath, cache, chunks, options, isTurn } = config;
  const images = files.map(async (filePath) => {
    const fileRootPath = _path2.default.resolve(outputPath, filePath);
    if (options.cache && cache.get(chunks[filePath])) {
      fs4.writeFileSync(fileRootPath, cache.get(chunks[filePath]));
      logger(_chalk2.default.blue(filePath), _chalk2.default.green("\u2728 The file has been cached"));
      return Promise.resolve();
    }
    const start = Date.now();
    const oldSize = fs4.lstatSync(fileRootPath).size;
    let newSize = oldSize;
    const ext = _nullishCoalesce(_path2.default.extname(_path2.default.resolve(outputPath, filePath)).slice(1), () => ( ""));
    const res = options.conversion.find((item) => `${item.from}`.includes(ext));
    const itemConversion = isTurn && (res == null ? void 0 : res.from) === ext;
    const type = itemConversion ? res == null ? void 0 : res.to : sharpEncodeMap.get(ext);
    const current = encodeMap.get(type);
    const filepath = `${fileRootPath.replace(
      ext,
      itemConversion ? current : ext
    )}`;
    const currentType = options.conversion.find(
      (item) => item.from === extname(fileRootPath).slice(1)
    );
    let resultBuffer;
    const fileExt = extname(fileRootPath).slice(1);
    if (currentType !== void 0) {
      const merge = {
        ...sharpOptions[ext],
        ...options.compress[currentType.to]
      };
      resultBuffer = await _sharp2.default.call(void 0, fileRootPath)[sharpEncodeMap.get(currentType.to)](merge).toBuffer();
    } else {
      const merge = { ...sharpOptions[ext], ...options.compress[ext] };
      resultBuffer = await _sharp2.default.call(void 0, fileRootPath)[sharpEncodeMap.get(fileExt)](merge).toBuffer();
    }
    await _fs.promises.writeFile(filepath, resultBuffer);
    const data = await _fs.promises.stat(filepath);
    newSize = data.size;
    if (newSize < oldSize) {
      if (options.cache && !cache.get(chunks[filePath])) {
        cache.set(chunks[filePath], await _fs.promises.readFile(filepath));
      }
      if (itemConversion) {
        fs4.unlinkSync(fileRootPath);
      }
      compressSuccess(
        `${filepath.replace(process.cwd(), "")}`,
        newSize,
        oldSize,
        start
      );
    }
  });
  await Promise.all(images);
}
var sharp_default = initSharp;

// src/core/context.ts
var CurrentNodeVersion2 = parseInt(process.version.slice(1), 10);
var SquooshErrorVersion2 = 18;
var SquooshUseFlag2 = CurrentNodeVersion2 < SquooshErrorVersion2;
var SquooshPool2;
if (SquooshUseFlag2) {
  Promise.resolve().then(() => _interopRequireWildcard(require("@squoosh/lib"))).then((module) => {
    SquooshPool2 = module.ImagePool;
    delete globalThis.navigator;
  }).catch((err) => {
    console.log(err);
  });
}
var extRE2 = /\.(png|jpeg|jpg|webp|wb2|avif)$/i;
var extSvgRE = /\.(png|jpeg|jpg|webp|wb2|avif|svg)$/i;
var Context = class {
  constructor() {
    this.imageModulePath = [];
    this.files = [];
    this.assetPath = [];
    this.filter = _pluginutils.createFilter.call(void 0, extSvgRE, [
      /[\\/]node_modules[\\/]/,
      /[\\/]\.git[\\/]/
    ]);
  }
  /**
   * @param userConfig
   * configResolved hook  解析用户参数以及vite参数
   * Parsing user parameters and vite parameters
   */
  handleResolveOptionHook(userConfig) {
    const {
      base,
      command,
      root: root2,
      build: { assetsDir, outDir },
      options
    } = userConfig;
    const cwd2 = process.cwd();
    const isBuild = command === "build";
    const cacheDir = join(
      root2,
      "node_modules",
      options.cacheDir,
      "unplugin-imagemin"
    );
    const isTurn = isTurnImageType(options.conversion);
    const outputPath = resolve(root2, outDir);
    const chooseConfig = {
      base,
      command,
      root: root2,
      cwd: cwd2,
      outDir,
      assetsDir,
      options,
      isBuild,
      cacheDir,
      outputPath,
      isTurn
    };
    this.mergeConfig = resolveOptions(defaultOptions, chooseConfig);
    this.config = chooseConfig;
  }
  /**
   *
   * @param id
   * @returns
   * load hooks  解析id 返回自定义内容 后续生成自定义bundle
   * Parsing id returns custom content and then generates custom bundle
   */
  loadBundleHook(id) {
    const imageModuleFlag = this.filter(id);
    const exportValue = this.generateDefaultValue(imageModuleFlag, id);
    return exportValue;
  }
  /**
   *
   * @param bundler
   * 根据构建前获取用户自定义模块内容 动态生成chunk file
   * Dynamically generate chunk file according to the content of user-defined module obtained before building
   */
  async generateBundleHook(bundler) {
    this.chunks = bundler;
    if (!await exists(this.config.cacheDir)) {
      await _promises.mkdir.call(void 0, this.config.cacheDir, { recursive: true });
    }
    let imagePool;
    const { mode } = this.config.options;
    const useModeFlag = resolveNodeVersion();
    if (mode === "squoosh" && !useModeFlag) {
      console.log(
        _chalk2.default.yellow(
          "Squoosh mode is not supported in node 18. change use sharp..."
        )
      );
    }
    let changeMode = useModeFlag ? mode : "sharp";
    if (changeMode === "squoosh" && SquooshUseFlag2) {
      imagePool = new SquooshPool2();
    }
    this.startGenerate();
    let spinner;
    spinner = await loadWithRocketGradient("");
    if (this.imageModulePath.length > 0) {
      const generateImageBundle = this.imageModulePath.map(async (item) => {
        if (extname(item) !== ".svg") {
          if (changeMode === "squoosh" && SquooshUseFlag2) {
            const squooshBundle = await this.generateSquooshBundle(
              imagePool,
              item
            );
            return squooshBundle;
          } else if (changeMode === "sharp") {
            const sharpBundle = await this.generateSharpBundle(item);
            return sharpBundle;
          }
        }
        const svgBundle = this.generateSvgBundle(item);
        return svgBundle;
      });
      const result = await Promise.all(generateImageBundle);
      if (changeMode === "squoosh") {
        imagePool.close();
      }
      this.generateBundleFile(bundler, result);
      logger(pluginTitle("\u2728"), _chalk2.default.yellow("Successfully"));
    } else {
      console.log(
        _chalk2.default.yellow(
          'Not Found Image Module,  if you want to use style with image style, such as "background-image" you can use "beforeBundle: false" in plugin config'
        )
      );
      if (changeMode === "squoosh") {
        imagePool.close();
      }
    }
    spinner.text = _chalk2.default.yellow("Image conversion completed!");
    spinner.succeed();
  }
  /**
   *
   * @param bundle
   * 根据构建后transform已有chunk replace 代码结构 解析 css 与 js 模块
   */
  TransformChunksHook(bundle) {
    this.filterBundleFile(bundle);
    this.transformCodeHook(bundle);
  }
  setAssetsPath(path5) {
    this.assetPath.push(path5);
  }
  filterBundleFile(bundle) {
    Object.keys(bundle).forEach((key) => {
      const { outputPath } = this.config;
      filterFile(resolve(outputPath, key), extRE2) && this.files.push(key);
    });
  }
  async transformCodeHook(bundle) {
    const allBundles = Object.values(bundle);
    const chunkBundle = allBundles.filter((item) => item.type === "chunk");
    const assetBundle = allBundles.filter((item) => item.type === "asset");
    const imageBundle = assetBundle.filter(
      (item) => item.fileName.match(extRE2)
    );
    const imageFileBundle = imageBundle.map((item) => item.fileName);
    const needTransformAssetsBundle = assetBundle.filter(
      (item) => filterExtension(item.fileName, "css")
    );
    transformCode(
      this.config.options,
      needTransformAssetsBundle,
      imageFileBundle,
      "source"
    );
    transformCode(this.config.options, chunkBundle, imageFileBundle, "code");
  }
  generateDefaultValue(imageModuleFlag, id) {
    if (imageModuleFlag) {
      const { path: path5 } = parseId(id);
      this.imageModulePath.push(path5);
      const generateSrc = getBundleImageSrc(path5, this.config.options);
      const base = basename(path5, extname(path5));
      const generatePath = join(
        `${this.config.base}${this.config.assetsDir}`,
        `${base}-${generateSrc}`
      );
      return `export default ${devalue_default(generatePath)}`;
    }
  }
  // squoosh
  async generateSquooshBundle(imagePool, item) {
    const start = _perf_hooks.performance.now();
    const size2 = await _fs.promises.lstat(item);
    const oldSize = size2.size;
    let newSize = oldSize;
    const ext = _nullishCoalesce(extname(item).slice(1), () => ( ""));
    const userRes = this.config.options.conversion.find(
      (i) => `${i.from}`.includes(ext)
    );
    const type = this.config.isTurn && (userRes == null ? void 0 : userRes.to) ? encodeMapBack.get(userRes == null ? void 0 : userRes.to) : encodeMapBack.get(ext);
    const image = imagePool.ingestImage(item);
    const defaultSquooshOptions = {};
    Object.keys(defaultOptions).forEach(
      (key) => defaultSquooshOptions[key] = { ...this.mergeConfig[key] }
    );
    const currentType = {
      [type]: defaultSquooshOptions[type]
    };
    await image.encode(currentType);
    const generateSrc = getBundleImageSrc(item, this.config.options);
    const baseDir = basename(item, extname(item));
    const { cacheDir, assetsDir } = this.config;
    const imageName = `${baseDir}-${generateSrc}`;
    const encodedWith = await image.encodedWith[type];
    newSize = encodedWith.size;
    const source = {
      fileName: join(assetsDir, imageName),
      name: imageName,
      // source: (await fs.readFile(cachedFilename)) as any,
      source: encodedWith.binary,
      isAsset: true,
      type: "asset"
    };
    const { base, outDir } = this.config;
    compressSuccess(
      join(base, outDir, source.fileName),
      newSize,
      oldSize,
      start
    );
    return source;
  }
  async generateSharpBundle(item) {
    const start = _perf_hooks.performance.now();
    const size2 = await _fs.promises.lstat(item);
    const oldSize = size2.size;
    let newSize = oldSize;
    const sharpFileBuffer = await loadImage(item, this.config.options);
    const generateSrc = getBundleImageSrc(item, this.config.options);
    const base = basename(item, extname(item));
    const source = await writeImageFile(
      sharpFileBuffer,
      this.config,
      `${base}-${generateSrc}`
    );
    newSize = sharpFileBuffer.length;
    const { outDir } = this.config;
    compressSuccess(
      join(this.config.base, outDir, source.fileName),
      newSize,
      oldSize,
      start
    );
    return source;
  }
  generateBundleFile(bundler, result) {
    result.forEach((asset) => {
      bundler[asset.fileName] = asset;
    });
  }
  startGenerate() {
    console.log("\n");
    const info = _chalk2.default.gray("Process start with");
    const modeLog = _chalk2.default.magenta(`Mode ${this.config.options.mode}`);
    logger(pluginTitle("\u{1F4E6}"), info, modeLog);
  }
  // close bundle
  async closeBundleHook() {
    if (!this.config.options.beforeBundle) {
      this.startGenerate();
      await this.spinnerHooks(this.closeBundleFn);
      this.transformHtmlModule();
    }
    return true;
  }
  async transformHtmlModule() {
    const htmlBundlePath = `${this.config.outDir}/index.html`;
    const html = await _fs.promises.readFile(resolve(process.cwd(), htmlBundlePath));
    const htmlBuffer = _buffer.Buffer.from(html);
    const htmlCodeString = htmlBuffer.toString();
    let newFile = "";
    this.config.options.conversion.forEach(async (item) => {
      const pattern = new RegExp(item.from, "g");
      newFile = newFile.length > 0 ? newFile.replace(pattern, item.to) : htmlCodeString.replace(pattern, item.to);
      await _fs.promises.writeFile(resolve(process.cwd(), htmlBundlePath), newFile);
    });
  }
  async spinnerHooks(fn) {
    if (!this.files.length) {
      return false;
    }
    let spinner;
    spinner = await loadWithRocketGradient("");
    await fn.call(this);
    logger(pluginTitle("\u2728"), _chalk2.default.yellow("Successfully"));
    spinner.text = _chalk2.default.yellow("Image conversion completed!");
    spinner.succeed();
  }
  async generateSvgBundle(item) {
    const svgCode = await _fs.promises.readFile(item, "utf8");
    const result = _svgo.optimize.call(void 0, svgCode, {
      // optional but recommended field
      // path, // all config fields are also available here
      multipass: true
    });
    const generateSrc = getBundleImageSrc(item, this.config.options);
    const base = basename(item, extname(item));
    const { assetsDir, outDir } = this.config;
    const imageName = `${base}-${generateSrc}`;
    const start = _perf_hooks.performance.now();
    const size2 = await _fs.promises.lstat(item);
    const oldSize = size2.size;
    let newSize = _buffer.Buffer.byteLength(result.data);
    const svgResult = {
      fileName: join(assetsDir, imageName),
      name: imageName,
      source: result.data,
      isAsset: true,
      type: "asset"
    };
    compressSuccess(
      join(this.config.base, outDir, svgResult.fileName),
      newSize,
      oldSize,
      start
    );
    return svgResult;
  }
  async closeBundleFn() {
    const { isTurn, outputPath } = this.config;
    const { mode, cache } = this.config.options;
    const defaultSquooshOptions = {};
    Object.keys(defaultOptions).forEach(
      (key) => defaultSquooshOptions[key] = { ...this.mergeConfig[key] }
    );
    if (cache) {
      this.cache = new Cache({ outputPath });
    }
    const initOptions = {
      files: this.files,
      outputPath,
      inputPath: this.assetPath,
      options: this.config.options,
      isTurn,
      cache,
      chunks: this.chunks
    };
    if (mode === "squoosh" && SquooshUseFlag2) {
      await squoosh_default({ ...initOptions, defaultSquooshOptions });
    } else if (mode === "sharp") {
      await sharp_default(initOptions);
    } else {
      throw new Error(
        "[unplugin-imagemin] Only squoosh or sharp can be selected for mode option"
      );
    }
  }
};
async function writeImageFile(buffer, options, imageName) {
  const { cacheDir, assetsDir } = options;
  const cachedFilename = join(cacheDir, imageName);
  if (!await exists(cachedFilename)) {
  }
  return {
    fileName: join(assetsDir, imageName),
    name: imageName,
    source: buffer,
    isAsset: true,
    type: "asset"
  };
}
async function convertToSharp(inputImg, options) {
  const currentType = options.conversion.find(
    (item) => item.from === extname(inputImg).slice(1)
  );
  let res;
  const ext = extname(inputImg).slice(1);
  if (currentType !== void 0) {
    const merge = {
      ...sharpOptions[ext],
      ...options.compress[currentType.to]
    };
    res = await _sharp2.default.call(void 0, inputImg)[sharpEncodeMap.get(currentType.to)](merge).toBuffer();
  } else {
    const merge = {
      ...sharpOptions[ext],
      ...options.compress[ext]
    };
    res = await _sharp2.default.call(void 0, inputImg)[sharpEncodeMap.get(ext)](merge).toBuffer();
  }
  return res;
}
function getBundleImageSrc(filename, options) {
  const currentType = _nullishCoalesce(options.conversion.find(
    (item) => item.from === extname(filename).slice(1)
  ), () => ( extname(filename).slice(1)));
  const id = generateImageID(
    filename,
    _nullishCoalesce(currentType.to, () => ( extname(filename).slice(1)))
  );
  return id;
}
async function loadImage(url, options) {
  const image = convertToSharp(url, options);
  return image;
}
function resolveOptions(options, configOption) {
  var _a;
  const transformType = transformEncodeType((_a = configOption.options) == null ? void 0 : _a.compress);
  const keys = Object.keys(transformType);
  const res = keys.map(
    (item) => ({
      ...options[item],
      ...transformType[item]
    })
  );
  const obj = {};
  keys.forEach((item, index) => {
    obj[item] = res[index];
  });
  return { ...options, ...obj };
}
function transformEncodeType(options = {}) {
  const newCompressOptions = {};
  const transformKeys = Object.keys(options).map(
    (item) => encodeMapBack.get(item)
  );
  const transformOldKeys = Object.keys(options).map((item) => item);
  transformKeys.forEach((item, index) => {
    newCompressOptions[item] = options[transformOldKeys[index]];
  });
  return newCompressOptions;
}
function transformCode(options, currentChunk, changeBundle, sourceCode) {
  currentChunk.forEach((item) => {
    options.conversion.forEach(
      (type) => {
        changeBundle.forEach((file) => {
          if (file.includes(type.from)) {
            const name = transformFileName(file);
            item[sourceCode] = item[sourceCode].replace(
              `${name}${type.from}`,
              `${name}${encodeMap.get(type.to)}`
            );
          }
        });
      }
    );
  });
}
function resolveNodeVersion() {
  const currentVersion = process.versions.node;
  const requiredMajorVersion = parseInt(currentVersion.split(".")[0], 10);
  const minimumMajorVersion = 14;
  if (requiredMajorVersion < minimumMajorVersion) {
    return true;
  }
  return false;
}

// src/index.ts
var PLUGIN_NAME = "unplugin:webpack";
delete globalThis.navigator;
var src_default = _unplugin.createUnplugin.call(void 0, (options = {}) => {
  const ctx = new Context();
  const assignOptions = Object.assign({}, resolveDefaultOptions, options);
  return {
    name: "unplugin-imagemin",
    apply: "build",
    enforce: "pre",
    async configResolved(config) {
      ctx.handleResolveOptionHook({ ...config, options: assignOptions });
    },
    // vite: {
    async load(id) {
      if (assignOptions.beforeBundle) {
        const imageModule = ctx.loadBundleHook(id);
        if (imageModule) {
          return imageModule;
        }
      }
    },
    // },
    webpack(complier) {
      complier.hooks.done.tap(PLUGIN_NAME, () => {
      });
    },
    async generateBundle(_, bundler) {
      if (assignOptions.beforeBundle) {
        await ctx.generateBundleHook(bundler);
      } else {
        ctx.TransformChunksHook(bundler);
      }
    },
    closeBundle: {
      sequential: true,
      async handler() {
        await ctx.closeBundleHook();
      }
    }
  };
});



exports.src_default = src_default;
/*! Bundled license information:

filesize/dist/filesize.esm.js:
  (**
   * filesize
   *
   * @copyright 2023 Jason Mulligan <jason.mulligan@avoidwork.com>
   * @license BSD-3-Clause
   * @version 10.0.7
   *)
*/
